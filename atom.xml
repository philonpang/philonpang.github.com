<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[philon的博客]]></title>
  <link href="http://ios.devphilon.com/atom.xml" rel="self"/>
  <link href="http://ios.devphilon.com/"/>
  <updated>2015-11-25T11:18:22+08:00</updated>
  <id>http://ios.devphilon.com/</id>
  <author>
    <name><![CDATA[philon]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[App性能监控-newRelicSDK使用及拦截上报方案]]></title>
    <link href="http://ios.devphilon.com/blog/2015/11/25/appxing-neng-jian-kong-newrelicsdkshi-yong-ji-lan-jie-shang-bao-fang-an/"/>
    <updated>2015-11-25T09:38:34+08:00</updated>
    <id>http://ios.devphilon.com/blog/2015/11/25/appxing-neng-jian-kong-newrelicsdkshi-yong-ji-lan-jie-shang-bao-fang-an</id>
    <content type="html"><![CDATA[<p>随着应用的发展越来越大，产品的开发和测试逐渐开始关注app的在线运行性能。最近一直在关注这个方向，说一下自己的心得和体会。</p>

<p>所谓的性能监控，并不是做出一堆花哨的图表让人赏心悦目。其实目的只有两个，一个是能够实时发现线上的问题，通过报警机制通知到相关负责人；另外一个就是能够看到历史数据，供测试和开发进行性能优化。那么监控的关键是确定监控指标，在监控指标的指导下确定需要客户端打点收集的日志。</p>

<h3>APP性能监控指标</h3>

<p>最近调研了一下这个方向，行业内把这个方向称为APM（application performance management）。国内外都有不少公司在做这方面的产品，一些大公司为了防止应用监控数据的外泄，也会自行开发性能监控管理平台。国内做得比较好的如基调、博睿、云测、听云等，国外有New Relic、Blueware、OneAPM等。 各个平台的技术方案大同小异（这里主要说的是IOS平台），提供一个集成到应用的SDK（static framework 或者 .a 文件）, 然后收集日志上报到其后台进行数据处理和纬度分析。这些平台的商业策略一般都是先免费提供试用，再进行租用收费的方式。</p>

<p>APP的性能指标主要分为两大类：InterActions（UI交互） 和 Network （网络连接）。在这两个大分类下，会有如下细分指标：</p>

<p>InterActions：(按时间-版本：＋device类型，＋os类型)</p>

<ul>
<li>APP启动次数、APP启动平均时间；</li>
<li>Controller display次数、平均display时间；</li>
<li>Controller display过程中各个method（包括UI thread、worker thread中的method）的平均执行时间；</li>
</ul>


<p>Network方面：（按时间-版本：＋域名，＋地区，＋运营商， ＋连接网络类型）</p>

<ul>
<li>平均相应时间</li>
<li>rpm（一分钟请求次数）</li>
<li>总耗时</li>
<li>传输数据大小</li>
<li>再具体到某个API接口：</li>
</ul>


<blockquote><p> (1) 平均http响应时间 （区分web Application（webview） 和 network）；
 (2) rpm；
 (3) 平均数据传输大小（区分send和receive）；</p></blockquote>

<p> 在两大指标上会增加如下方面的维度： 接入网络、运营商、设备、系统版本、地区、app版本、统计时间；</p>

<h3>NewRelic SDK使用说明</h3>

<p>我主要关注了国内的听云平台和国外的NewRelic平台。国内听云的统计平台注册只能看到非常基础的统计，一点细分分析维度，就提示你升级套餐，当然你可以申请14天免费试用，然后就是市场给你打电话过来。 其SDK中的framework也只提供一个头文件，想要对统计数据的定制基本上没有。于是果断切换到国外的newRelic平台，newRlic平台需要vpn访问才能快点，一注册所有的功能都能够试用，当然试用期也只有14天。</p>

<p>关注一下SDK的使用，SDK提供了众多可配置的头文件，让你能够更加清楚的了解sdk提供的功能；</p>

<p>（1）最基础的使用，当然就是通过Apptoken注册使用：(注意一下，newRelic集成在debug时会检查当前应用中hook的使用，需要将newrelic的注册使用放到所有hook之后，一般放到appdidfinishLaunch靠后的位置)</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>#import &lt;NewRelicAgent/NewRelic.h&gt;
</span><span class='line'>
</span><span class='line'>[NewRelicAgent startWithApplicationToken:@"token"];
</span></code></pre></td></tr></table></div></figure>


<p>如果是最基础的用法，我们可以通过charles拦截其数据上报，可以发现request和response的数据都是通过ssl加密、https传输，看不到明文数据。如果需要看到明文数据可以使用非加密接口<code>+ (void)startWithApplicationToken:(NSString*)appToken withoutSecurity:(BOOL)disableSSL</code></p>

<p>(2) SDK集成了各种指标收集，包括Interaction、SwiftInteraction、Crash、NSURLSession、HTTPResponse等。如下代码所示：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>typedef NS_OPTIONS(unsigned long long, NRMAFeatureFlags){
</span><span class='line'>    NRFeatureFlag_InteractionTracing                    = 1 &lt;&lt; 1,
</span><span class='line'>    NRFeatureFlag_SwiftInteractionTracing               = 1 &lt;&lt; 2, //disabled by default 
</span><span class='line'>    NRFeatureFlag_CrashReporting                        = 1 &lt;&lt; 3,
</span><span class='line'>    NRFeatureFlag_NSURLSessionInstrumentation           = 1 &lt;&lt; 4,
</span><span class='line'>    NRFeatureFlag_HttpResponseBodyCapture               = 1 &lt;&lt; 5,
</span><span class='line'>    NRFeatureFlag_ExperimentalNetworkingInstrumentation = 1 &lt;&lt; 13, //disabled by default
</span><span class='line'>    NRFeatureFlag_AllFeatures                           = ~0ULL //in 32-bit land the alignment is 4bytes
</span><span class='line'>};</span></code></pre></td></tr></table></div></figure>


<p>你可以按照自己的需要指定需要收集的指标数据，使用<code>+ (void) enableFeatures:(NRMAFeatureFlags)featureFlags; 或 + (void) disableFeatures:(NRMAFeatureFlags)featureFlags;</code>.</p>

<p>(3) 关于Interaction的主要方案就是hook controller中的各个生命周期方法，NewRelicSDK中主要拦截了如下方法：</p>

<p>UIViewController</p>

<ol>
<li>viewDidLoad</li>
<li>viewWillAppear:</li>
<li>viewDidAppear:</li>
<li>viewWillDisappear:</li>
<li>viewDidDisappear:</li>
<li>viewWillLayoutSubviews</li>
<li>viewDidLayoutSubviews</li>
</ol>


<p>UIImage:</p>

<ol>
<li>imageNamed:</li>
<li>imageWithContentsOfFile:</li>
<li>imageWithData:</li>
<li>imageWithData:scale:</li>
<li>initWithContentsOfFile:</li>
<li>initWithData:</li>
<li>initWithData:scale:</li>
</ol>


<p>NSJSONSerialization:</p>

<ol>
<li>JSONObjectWithData:options:error:</li>
<li>JSONObjectWithStream:options:error:</li>
<li>dataWithJSONObject:options:error:</li>
<li>writeJSONObject:toStream:options:error:</li>
</ol>


<p>NSManagedObjectContext</p>

<ol>
<li>executeFetchRequest:error:</li>
<li>processPendingChanges</li>
</ol>


<p>(4)在ARC模式下，你也可以使用如下宏拦截你想统计的应用中关键方法：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>- (void)myMethod
</span><span class='line'>{
</span><span class='line'>  NR_TRACE_METHOD_START(0);
</span><span class='line'>
</span><span class='line'>  // … existing code
</span><span class='line'>
</span><span class='line'>  NR_TRACE_METHOD_STOP;
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>更多的使用请关注其SDK文档说明：<a href="https://docs.newrelic.com/docs/mobile-monitoring/mobile-sdk-api/new-relic-mobile-sdk-api/work-ios-sdk-api">https://docs.newrelic.com/docs/mobile-monitoring/mobile-sdk-api/new-relic-mobile-sdk-api/work-ios-sdk-api</a></p>

<h3>newRelic SDK的数据拦截上报</h3>

<p>newRelic SDK已经做得非常精致，但是如果我们不想把数据上报到第三方平台管理，那应该怎么办呢，自己去研发一套，耗时费力，而且还费力不讨好。那何不做一个数据拦截，把数据转发到我们自己的后台平台呢？</p>

<p>static framework public的头文件并不包括上传class的头文件，但是当网络不好或者没有网的时候，我们可以从控制台打印上报数据失败的日志看到一些端倪，我们可以找到上传日志的方法所在的类为“NRMAHarvesterConnection”，如果是ssl上传，日志为send方法，如果是非ssl上传，日志中显示为sendData方法；</p>

<p>为了更好的知道类中方法的分布，我们可以用class-dump-z工具解析出SDK中所有的头文件。 class-dump-z是不能直接dump framework中的头文件，解析出来的头文件中会有一个source 为null的提示。 一开始觉得可能是因为framework做了加密处理，找了一个越狱机器在cydia中安装了openssh-how-to工具，通过sftp把framework和Clutch上传到越狱机器中，开始用Clutch进行解密，发现Clutch并不能直接解析，也不能解析debug安装的调试app。</p>

<p>最后终于将集成了newRelic SDK的的app 通过archive打包，导出一个ipa。解压出app目录之后，再用class-dump-z工具对app目录的二进制文件进行头文件导出，这时候我们就能够看到sdk中的所有头文件了；</p>

<p>我找到“NRMAHarvesterConnection”文件，如下所示，可以看到其中的sendData方法。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>#import &lt;XXUnknownSuperclass.h&gt; // Unknown library
</span><span class='line'>
</span><span class='line'>@class NRMAConnectInformation, NSString;
</span><span class='line'>
</span><span class='line'>@interface NRMAHarvesterConnection : XXUnknownSuperclass {
</span><span class='line'>  BOOL _useSSL;
</span><span class='line'>  NRMAConnectInformation* _connectionInformation;
</span><span class='line'>  NSString* _collectorHost;
</span><span class='line'>  NSString* _applicationToken;
</span><span class='line'>  NSString* _crossProcessID;
</span><span class='line'>  long long _serverTimestamp;
</span><span class='line'>}
</span><span class='line'>@property(assign) BOOL useSSL;
</span><span class='line'>@property(retain) NSString* crossProcessID;
</span><span class='line'>@property(assign) long long serverTimestamp;
</span><span class='line'>@property(retain) NSString* applicationToken;
</span><span class='line'>@property(retain) NSString* collectorHost;
</span><span class='line'>@property(retain) NRMAConnectInformation* connectionInformation;
</span><span class='line'>-(void).cxx_destruct;
</span><span class='line'>-(id)collectorHostURL:(id)url;
</span><span class='line'>-(id)collectorHostDataURL;
</span><span class='line'>-(id)collectorConnectURL;
</span><span class='line'>-(id)createDataPost:(id)post;
</span><span class='line'>-(id)createConnectPost:(id)post;
</span><span class='line'>-(id)sendData:(id)data;
</span><span class='line'>-(id)sendConnect;
</span><span class='line'>-(id)send:(id)send;
</span><span class='line'>-(id)createPostWithURI:(id)uri message:(id)message;
</span><span class='line'>-(id)init;
</span><span class='line'>@end</span></code></pre></td></tr></table></div></figure>


<p>为了更好的了解方法的输入和输出参数，我使用了阿里最近开源的ali-wax的lua调试工具进行了sendData的方法的输入输出了解, 我们可以看到输入参数data的class类型，是一个“NRMAHarvestData”，我们同样可以找到其头文件，查询到里面的JSONObject方法，可以把data转化成一个json对象。 得到这个对象了我们就可以将数据转发到我们自己的平台，并伪造一个http上传成功或失败的对象给sendData方法进行内存数据删除处理即可。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>waxClass{"NRMAHarvesterConnection"}
</span><span class='line'>
</span><span class='line'>--如果需要上报，拦截这个方法即可
</span><span class='line'>function sendData(self,data)
</span><span class='line'>  print(data:class())
</span><span class='line'>  jsonObject = data:JSONObject()
</span><span class='line'>  self:ORIGsendData(data)
</span><span class='line'>end
</span></code></pre></td></tr></table></div></figure>


<p>注：这里我只提供一种方案，公司产品并没有采用这种方法，因为我们自己的性能监控虽然数据粒度不够，已经足够日常查询问题使用了。更多是分享一下取巧的思路，以及纪录一下破解的过程。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Ali-Wax使用和源码解析系列-Wax的集成和调试环境搭建]]></title>
    <link href="http://ios.devphilon.com/blog/2015/11/20/ali-waxshi-yong-he-yuan-ma-jie-xi-xi-lie-waxde-ji-cheng-he-diao-shi-huan-jing-da-jian/"/>
    <updated>2015-11-20T11:10:11+08:00</updated>
    <id>http://ios.devphilon.com/blog/2015/11/20/ali-waxshi-yong-he-yuan-ma-jie-xi-xi-lie-waxde-ji-cheng-he-diao-shi-huan-jing-da-jian</id>
    <content type="html"><![CDATA[<h2>那些多余的话</h2>

<p>在ios平台的基础框架中，代码的直接动态部署一直是一个无法解决的问题，所以我们只能退而求其次，通过建立脚本语言和OC的bridge来实现动态更新的目标。在这个方向上，wax-lua框架是第一个解决方案，但是随着wax-lua作者的放弃维护，wax框架逐渐被降级为做补丁修复的工具。之后随着objc语言的完善和SDK中JavaScriptCore（webkit）framework api的开放，另外一种脚本语言js以一种更为被苹果认可的姿态进入了这个方向，先有国外FaceBook发布的ReactNative框架，让更多的前端开发者可以通过js语言完成可以毗邻native效果的app，后有国内腾讯的bang开源JSPatch，专注于ios平台Patch修复。</p>

<p>本人最近一直在维护公司内部的的wax框架，也一直在探索ios热更新方向上的新技术。先是wax框架的兼容64位维护，wax框架集成到产品后多个组件交叉使用runtime的bug修复；再是探索Tianium跨平台JS框架；再到FaceBook出品开源的ReactNative框架；再到最后的JSPatch&hellip; 这些框架的源码和Demo我都有涉及，从希望到失望&hellip;首先是自己维护的wax框架稳健性不够，特别是通过AOP+forward兼容64位后bug频现，用作patch热更新尚且能够应付，但是想用来做组件动态部署成熟度还不够。其次Tianium框架，关于jscore部分没有开源不敢用，另外其bind oc api部分需要时刻跟进新版本的SDK是一个low点。 再其次是ReactNative框架，源码我没有怎么看，但是我写了一个稍微复杂的页面，当图片在同一个页面加载较多的时候，卡顿的现象特别明显，让我对js的效率产生了深深的怀疑。 JSPatch同样是利用了forward消息转发机制完成了js和oc的bind，但是社区和框架成熟度仍然不够。</p>

<p>最近阿里开源了增强版的wax框架，我连续看了两天源码，对其增强部分的实现有了一个大致的了解，也让我对lua-bind的方案有了很大的信心。之前受Andfix android平台热更新框架思路的影响，自己很想在这条路上再继续折腾一番：如果能够把OC代码通过一个转换器转化成lua代码，ios平台的准直接动态部署应该是可以实现的。 所有的开发人员仍然用自己最熟悉的objc开发需求，测试和发版，比较版本代码的不同可以让低版本的产品用户使用高版本的功能。我们可以不按照版本发布，转而按照模块开发，所有的新需求和新运营方案都可以在不发版的情况推送给用户。</p>

<h2>Ali-Wax简介</h2>

<p>代码地址：<a href="https://github.com/alibaba/wax.git">https://github.com/alibaba/wax.git</a></p>

<p><strong>wax-lua 的语言优势：</strong></p>

<ul>
<li>(1)自动垃圾回收：再也不用使用alloc，retain和release；</li>
<li>(2)代码少：没有头文件，没有static类型、array常量、dictionary常量；</li>
<li>(3)能够使用任何一个framework，例如cocoa、UITouch、Fondation等，任何用oc写的framework，wax自动将其暴露给lua使用；</li>
<li>(4)超级简单的http请求： 和REST的web service一起交互使用；</li>
<li>(5)lua也有函数闭包，也就是所谓的blocks；</li>
<li>(6)lua有内置的Regex-like 模式匹配library；</li>
</ul>


<p><strong>相比原Wax框架：</strong></p>

<ul>
<li>64位支持；</li>
<li>线程安全；</li>
<li>其他一些特性：</li>
</ul>


<blockquote><ol>
<li>lua function 转化成 oc block，</li>
<li>在lua中调用oc block，</li>
<li>getting/setting 私有成员变量，</li>
<li>内置通用的C函数，</li>
<li>支持lua代码debug；</li>
</ol>
</blockquote>

<p>在接下来的博客系列中，我将结合Ali—Wax源码，介绍如何实现这些增强特性的，敬请期待。下面我们先来看看如何使用和集成wax框架和其debug环境。</p>

<h2>Ali-Wax的Podfile集成</h2>

<p>Wax框架只是一个热更新实现方案，我们用于具体的产品进行补丁修复或者功能组件发布还需要实现一个版本管理方案。在实现版本方案的时候，肯定涉及到在wax框架上的功能定制，比如说补丁现场恢复功能等（这部分功能我会开源到我的<a href="https://github.com/philonpang/wax.git">fork代码</a>中）。另外我们现在用CocoaPods管理我们的代码组件版本，为了方便各自的产品修复bug，发放版本。 我建议大家fork一份代码到自己的github中，进行版本管理。</p>

<p>fork Ali-Wax: <a href="https://github.com/philonpang/wax.git">https://github.com/philonpang/wax.git</a></p>

<p>另外Ali-Wax框架中集成了lua的debug方案：mobdebug，位于wax/tools/mobdebug处，作者配置了Podspec，可以直接pod到你的调试工程中。 这部分代码也不会有什么变化，已建议作者单独列一个git工程，目前我放到了自己的git空间里，大家可以共享。</p>

<p>mobdebug: <a href="https://github.com/philonpang/mobdebug.git">https://github.com/philonpang/mobdebug.git</a></p>

<p>这样我们就可以在项目工程中通过Pofile直接集成wax框架和代码调试环境了(当然你也可以通过path指向wax clone项目的本地)；podifle如下：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>source 'https://github.com/CocoaPods/Specs.git'
</span><span class='line'>
</span><span class='line'>platform :ios, '6.0'
</span><span class='line'>inhibit_all_warnings!
</span><span class='line'>
</span><span class='line'>workspace 'WLDWaxService'
</span><span class='line'>xcodeproj 'LDWaxService'
</span><span class='line'>
</span><span class='line'>target :LDWaxService do
</span><span class='line'>    pod 'wax', :git =&gt; 'https://github.com/philonpang/wax.git'
</span><span class='line'>    pod 'mobdebug', :git  =&gt; 'https://github.com/philonpang/mobdebug.git'
</span><span class='line'>    link_with 'LDWaxService'
</span><span class='line'>end
</span></code></pre></td></tr></table></div></figure>


<h2>Ali-Wax的luaDebug</h2>

<p>作者通过编译luasocket源代码支持了lua代码的ios环境调试。作者刚发布的时候的调试环境也折腾了我很久，我这里说一下我踩过的那些坑和注意事项。 官方调试安装步骤见<a href="https://github.com/alibaba/wax/tree/master/examples/LuaCodeDebug">https://github.com/alibaba/wax/tree/master/examples/LuaCodeDebug</a></p>

<ul>
<li>download <a href="https://github.com/pkulchenko/ZeroBraneStudio">ZeroBraneStudio</a> (lua代码调试IDE，直接git clone到本地)</li>
<li>run ZeroBraneStudio: 进入ZeroBraneStudio/zbstudio文件夹，直接双击ZeroBraneStudio.app文件即可运行（将app拷贝到application中不能运行）</li>
<li>import lua code: click the 6th button<img src="https://github.com/pkulchenko/ZeroBraneStudio/blob/master/zbstudio/res/24/DIR-SETUP.png?raw=true" alt="Smaller icon" />, choose your lua code&rsquo;s root directory</li>
<li>start debug server: click Project->Start Debugger Server. （每次打开ZeroBraneStudio的时候，记得打开这个选项）</li>
<li>run this code before you enter debug</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>wax_start(nil, nil);//must start before debug
</span><span class='line'>extern void luaopen_mobdebug_scripts(void* L);
</span><span class='line'>luaopen_mobdebug_scripts(wax_currentLuaState());</span></code></pre></td></tr></table></div></figure>


<ul>
<li>add<code>require('mobdebug').start('YOUR_MAC_IP_ADDRESS')</code>to your lua code. if you use simulator <code>'YOUR_MAC_IP_ADDRESS'</code> can be empty</li>
<li>launch your app，when <code>require('mobdebug').start()</code> is invoked, ZeroBraneStudio&rsquo;s dock will become active, then you should add breakpoint. (这种情况下，当你在模拟器中运行app后，会自动跳在ZeroBraneStudio中启动lua文件中断点下来)</li>
</ul>


<h3>坑1:import luaCode 的tip</h3>

<p>官方截图上看到的截图是整个xcode工程的目录，<strong>如果你import了整个工程，在目录和文件较多的情况下，ZeroBraneStudio中的断点是无效的</strong>。
其实你只需要import存放lua文件的目录即可。</p>

<h3>坑2:xcode工程中的lua代码文件</h3>

<p>xcode添加文件有两种方式：Create groups 和 Create folder reference两种。 按照前一种方式，你引入目录的所有文件在运行时会被拷贝到“XX.app/”目录下，而后面一种方式目录会以引用方式加入，运行时文件仍然放在“XX.app/拷贝目录/”下，而且当引入目录中有新文件添加的时候，不用再执行一遍添加操作。</p>

<p>所以我们在本地调试代码的时候，建议以第二种方式引入目录，这样我们可以随时在ZeroBraneStudio中添加文件（而不用在xcode工程中再进行一次add操作）进行调试。 但是执行lua代码中的require代码行时，会提示找不到对应的require文件。这其实是lua 默认search 文件的路径没有设置照成的，所以我们需要设置lua的search路径环境变量。 代码如下：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>#import "wax.h"
</span><span class='line'>#import "wax_http.h"
</span><span class='line'>#import "wax_json.h"
</span><span class='line'>#import "wax_xml.h"
</span><span class='line'>
</span><span class='line'>
</span><span class='line'>    //设置lua的search路径环境变量
</span><span class='line'>    NSString *patchPath = [[NSBundle mainBundle] pathForResource:@"patchDemo" ofType:nil];
</span><span class='line'>    NSString *pp = [NSString stringWithFormat:@"%@/?.lua;", patchPath];
</span><span class='line'>    setenv(LUA_PATH, [pp UTF8String], 1);
</span><span class='line'>
</span><span class='line'>    //启动wax框架和debug环境
</span><span class='line'>    wax_start(nil, luaopen_wax_http, luaopen_wax_json, luaopen_wax_xml, nil);//must start
</span><span class='line'>    extern void luaopen_mobdebug_scripts(void* L);
</span><span class='line'>    void * p = wax_currentLuaState();
</span><span class='line'>    luaopen_mobdebug_scripts(p);
</span><span class='line'>
</span><span class='line'>    //运行启动文件
</span><span class='line'>    wax_runLuaString("require('patch')");
</span></code></pre></td></tr></table></div></figure>


<p>完成以上步骤之后，你就可以在你的项目工程中开心的调试lua代码了。如下图所示：</p>

<p><img src="http://ios.devphilon.com/images/luadebugdemo.jpg"></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[IOS平台Hotfix框架:JSPatch学习笔记及和WaxPatch的集成]]></title>
    <link href="http://ios.devphilon.com/blog/2015/06/26/jspatchxue-xi-yi-ji-iosping-tai-hotfixzai-xian-bu-ding-guan-li-fang-an-shi-xian/"/>
    <updated>2015-06-26T14:59:32+08:00</updated>
    <id>http://ios.devphilon.com/blog/2015/06/26/jspatchxue-xi-yi-ji-iosping-tai-hotfixzai-xian-bu-ding-guan-li-fang-an-shi-xian</id>
    <content type="html"><![CDATA[<h2>关于HotfixPatch</h2>

<p>在IOS开发领域，由于Apple严格的审核标准和低效率，IOS应用的发版速度极慢，稍微大型的app发版基本上都在一个月以上，所以代码热更新（HotfixPatch）对于IOS应用来说就显得尤其重要。</p>

<p>现在业内基本上都在使用WaxPatch方案，由于Wax框架已经停止维护四五年了，所以waxPatch在使用过程中还是存在不少坑(比如参数转化过程中的问题，如果继承类没有实例化修改继承类的方法无效, wax_gc中对oc中instance的持有延迟释放&hellip;)。另外苹果对于Wax使用的态度也处于模糊状态，这也是一个潜在的使用风险。</p>

<p>随着FaceBook开源React Native框架，利用JavaScriptCore.framework直接建立JavaScript（JS）和Objective-C(OC)之间的bridge成为可能，JSPatch也在这个时候应运而生。最开始是从唐巧的微信公众号推送上了解到，开始还以为是在React Native的基础上进行的封装，不过最近仔细研究了源代码，跟React Native半毛钱关系都没有，这里先对JSPatch的作者（不是唐巧，是Bang，<a href="http://blog.cnbang.net/">博客地址</a>）赞一个。</p>

<p>深入了解JSPatch之后，第一感觉是这个方案小巧，易懂，维护成本低，直接通过OC代码去调用runtime的API，作为一个IOS开发者，很快就能看明白，不用花大精力去了解学习lua。另外在建立JS和OC的Bridge时，作者很巧妙的利用JS和OC两种语言的消息转发机制做了很优雅的实现，稍显不足的是JSPatch只能支持ios7及以上。</p>

<p>由于现在公司的部分应用还在支持ios6，完全取代Wax也不现实，但是一些新上应用已经直接开始支持ios7。个人觉得ios6和ios7的界面风格差别较大，相信应用最低支持版本会很快升级到ios7. 还考虑到JSPatch的成熟度不够，所以决定把JSPatch和WaxPatch结合在一起，相互补充进行使用。下面给大家说一些学习使用体会。</p>

<h2>JSPatch和WaxPatch对比</h2>

<p>关于JSPatch对比WaxPatch的优势，下面摘抄一下JSPatch作者的话：</p>

<ul>
<li><a href="http://blog.cnbang.net/works/2767/">来源: JSPatch – 动态更新iOS APP</a></li>
</ul>


<h4>方案对比</h4>

<p>目前已经有一些方案可以实现动态打补丁，例如WaxPatch，可以用Lua调用OC方法，相对于WaxPatch，JSPatch的优势：</p>

<ul>
<li><p>1.<strong>JS语言:</strong> JS比Lua在应用开发领域有更广泛的应用，目前前端开发和终端开发有融合的趋势，作为扩展的脚本语言，JS是不二之选。</p></li>
<li><p>2.<strong>符合Apple规则:</strong> JSPatch更符合Apple的规则。<a href="https://developer.apple.com/programs/terms/ios/standard/ios_program_standard_agreement_20140909.pdf">iOS Developer Program License Agreement</a>里3.3.2提到不可动态下发可执行代码，但通过苹果JavaScriptCore.framework或WebKit执行的代码除外，JS正是通过JavaScriptCore.framework执行的。</p></li>
<li><p>3.<strong>小巧:</strong> 使用系统内置的JavaScriptCore.framework，无需内嵌脚本引擎，体积小巧。</p></li>
<li><p>4.<strong>支持block:</strong> wax在几年前就停止了开发和维护，不支持Objective-C里block跟Lua程序的互传，虽然一些第三方已经实现block，但使用时参数上也有比较多的限制。</p></li>
</ul>


<p>JSPatch的劣势：</p>

<ul>
<li>相对于WaxPatch，JSPatch劣势在于不支持iOS6，因为需要引入JavaScriptCore.framework。另外目前内存的使用上会高于wax，持续改进中。</li>
</ul>


<h2>JSPatch的实现原理理解</h2>

<p>JSPatch的实现原理作者的博文已经很详细的介绍了，我这里就不多说了，贴一下学习之处：</p>

<ul>
<li>JSPatch实现原理详解 <a href="http://blog.cnbang.net/tech/2808/">http://blog.cnbang.net/tech/2808/</a></li>
<li>JSPatch Git源码和使用说明 <a href="https://github.com/bang590/JSPatch">https://github.com/bang590/JSPatch</a></li>
</ul>


<p>看实现原理详解的时候对照着源码看，比较好理解，我在这里说一下我对JSPatch的学习和理解：</p>

<h4>（1）OC的动态语言特性</h4>

<p>不管是WaxPatch框架还是JSPatch的方案，其根本原理都是利用OC的动态语言特性去动态修改类的方法实现。
OC的动态语言特性是在runtime system(全部用C实现，Apple维护了一份开源代码)上实现的，面向对象的Class和instance机制都是基于消息机制。我们平时认为的[object method]，正确的理解应该是[receiver sendMsg], 所有的消息发送会在编译阶段编译为runtime c函数的调用：_obj_sendMsg(id, SEL).</p>

<p>详细介绍参考博文：</p>

<ul>
<li><a href="http://justsee.iteye.com/blog/2163777">Objective-C Runtime详细介绍</a></li>
<li><a href="http://www.opensource.apple.com/source/objc4/">Objective-C Runtime源码_Apple</a></li>
</ul>


<p>runtime提供了一些运行时的API</p>

<ul>
<li>反射类和选择器</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>Class class = NSClassFromString("UIViewController");
</span><span class='line'>SEL selector = NSSelectorFromString("viewDidLoad");</span></code></pre></td></tr></table></div></figure>


<ul>
<li>为某个类新增或者替换方法选择器（SEL）的实现（IMP）</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>BOOL class_addMethod(Class cls, SEL name, IMP imp, const char *types);
</span><span class='line'>IMP class_replaceMethod(Class cls, SEL name, IMP imp, const char *types);</span></code></pre></td></tr></table></div></figure>


<ul>
<li>在runtime中动态注册类</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>Class superCls = NSClassFromString(superClassName);
</span><span class='line'>cls = objc_allocateClassPair(superCls, className.UTF8String, 0);
</span><span class='line'>objc_registerClassPair(cls);</span></code></pre></td></tr></table></div></figure>


<h4>（2）JS如何调用OC</h4>

<p>在JS运行环境中，需要解决两个问题，一个是OC类对象（objc_class）的获取，另一个就是使用对象提供的接口方法。</p>

<p>对于第一个问题，JSPatch在实现中是通过Require调用在JS环境下创建一个class同名对象（js形式），当向OC发送alloc接收消息之后，会将OC环境中创建的对象地址保存到这个这个js同名对象中，js本身并不完成任何对象的初始化。关于JS持有OC对象的引用，其回收的解释在JSPatch作者的博文中有介绍，没有具体测试。详见JSPatch.js代码：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>//请求OC类对象
</span><span class='line'>UIView = require("UIView");
</span><span class='line'>
</span><span class='line'>//缓存JS class同名对象
</span><span class='line'>var _require = function(clsName) {
</span><span class='line'>    if (!global[clsName]) {
</span><span class='line'>      global[clsName] = {
</span><span class='line'>        __isCls: 1,
</span><span class='line'>        __clsName: clsName
</span><span class='line'>      }
</span><span class='line'>    } 
</span><span class='line'>    return global[clsName]
</span><span class='line'>      }
</span><span class='line'>
</span><span class='line'>//调用class方法，返回OC实例化对象进行封装
</span><span class='line'>var ret = instance ? _OC_callI(instance, selectorName, args, isSuper):
</span><span class='line'>                     _OC_callC(clsName, selectorName, args)
</span><span class='line'>                     
</span><span class='line'>//OC创建后返回对象
</span><span class='line'>return@{@"__clsName": NSStringFromClass([obj class]), @"__obj": obj};
</span><span class='line'>    
</span><span class='line'>
</span><span class='line'>//JS中解析OC对象
</span><span class='line'>return _formatOCToJS(ret)
</span><span class='line'>
</span><span class='line'>//_formatOCToJS
</span><span class='line'>if (obj instanceof Object) {
</span><span class='line'>    var ret = {}
</span><span class='line'>    for (var key in obj) {
</span><span class='line'>      ret[key] = _formatOCToJS(obj[key])
</span><span class='line'>    }
</span><span class='line'>    return ret
</span><span class='line'> }
</span><span class='line'>
</span></code></pre></td></tr></table></div></figure>


<p>对于第二个问题，JSPatch在JS环境中通过中心转发方式，所有OC方法的调用均是通过新增Object（js）原型方法<em>c(methodName)完成调用，在通过JavaScriptCore执行JS脚本之前，先将所有的方法调用字符替换
</em>c(&lsquo;method&rsquo;)的方式； 在_c函数中通过JSContex建立的桥接函数传入参数和返回参数即完成了调用；</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>//字符替换
</span><span class='line'>static NSString *_regexStr = @"\\.\\s*(\\w+)\\s*\\(";
</span><span class='line'>static NSString *_replaceStr = @".__c(\"$1\")(";
</span><span class='line'>
</span><span class='line'>NSString *formatedScript = [NSString stringWithFormat:@"try{@}catch(e){_OC_catch(e.message, e.stack)}", [_regex stringByReplacingMatchesInString:script options:0 range:NSMakeRange(0, script.length) withTemplate:_replaceStr]];
</span><span class='line'>
</span><span class='line'>
</span><span class='line'>//__c()向OC转发调用参数
</span><span class='line'>Object.prototype.__c = function(methodName) {
</span><span class='line'>    
</span><span class='line'>    ...
</span><span class='line'>    
</span><span class='line'>    return function(){
</span><span class='line'>      var args = Array.prototype.slice.call(arguments)
</span><span class='line'>      return _methodFunc(self.__obj, self.__clsName, methodName, args, self.__isSuper)
</span><span class='line'>    }
</span><span class='line'> }
</span><span class='line'>  
</span><span class='line'>//_methodFunc调用桥接函数
</span><span class='line'>var _methodFunc = function(instance, clsName, methodName, args, isSuper) {
</span><span class='line'>  
</span><span class='line'>  ...
</span><span class='line'>  
</span><span class='line'>    var ret = instance ? _OC_callI(instance, selectorName, args, isSuper):
</span><span class='line'>                         _OC_callC(clsName, selectorName, args)
</span><span class='line'>
</span><span class='line'>    return _formatOCToJS(ret)
</span><span class='line'> }
</span><span class='line'>
</span><span class='line'>
</span><span class='line'>//OC中的桥接函数，JS和OC的桥接函数都是通过这样定义
</span><span class='line'>context[@"_OC_callI"] = ^id(JSValue *obj, NSString *selectorName, JSValue *arguments, BOOL isSuper) {
</span><span class='line'>    return callSelector(nil, selectorName, arguments, obj, isSuper);
</span><span class='line'>};
</span><span class='line'>
</span><span class='line'>context[@"_OC_callC"] = ^id(NSString *className, NSString *selectorName, JSValue *arguments) {
</span><span class='line'>    return callSelector(className, selectorName, arguments, nil, NO);
</span><span class='line'>};
</span></code></pre></td></tr></table></div></figure>


<h4>（3）JS如何替换OC方法</h4>

<p>JSPatch的主要作用还是通过脚本修复一些线上bug，希望能够达到替换OC方法的目标。JSPatch的实现巧妙之处在于：利用了OC的<a href="http://bugly.qq.com/blog/?p=64">消息转发机制</a>。</p>

<ul>
<li>1:替换原有selector的IMP实现为一个空的IMP实现，这样当objc_class接受到消息之后，就会进行消息转发, 另外需要将selector的初始实现进行保存；</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>//selector指向空实现
</span><span class='line'>IMP msgForwardIMP = getEmptyMsgForwardIMP(typeDescription, methodSignature);
</span><span class='line'>class_replaceMethod(cls, selector, msgForwardIMP, typeDescription);
</span><span class='line'>
</span><span class='line'>
</span><span class='line'>//保存原有实现，这里进行了修改，增加了恢复现场的支持
</span><span class='line'>NSString *originalSelectorName = [NSString stringWithFormat:@"ORIG@", selectorName];
</span><span class='line'>SEL originalSelector = NSSelectorFromString(originalSelectorName);
</span><span class='line'>if(class_respondsToSelector(cls, selector)) {
</span><span class='line'>    if(!class_respondsToSelector(cls, originalSelector)){
</span><span class='line'>        class_addMethod(cls, originalSelector, originalImp, typeDescription);
</span><span class='line'>    } else {
</span><span class='line'>        class_replaceMethod(cls, originalSelector, originalImp, typeDescription);
</span><span class='line'>    }
</span><span class='line'>}
</span></code></pre></td></tr></table></div></figure>


<ul>
<li>2:将替换的JS方法构造一个JPSelector及其IMP实现（根据返回参数构造），添加到当前class中，并通过cls＋selecotr全局缓存JS方法（全局缓存并没有多大用途，但是对于后面恢复现场比较有用）;</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>if (!_JSOverideMethods[clsName][JPSelectorName]) {
</span><span class='line'>    _initJPOverideMethods(clsName);
</span><span class='line'>    _JSOverideMethods[clsName][JPSelectorName] = function;
</span><span class='line'>    const char *returnType = [methodSignature methodReturnType];
</span><span class='line'>    IMP JPImplementation = NULL;
</span><span class='line'>    
</span><span class='line'>    //根据返回类型构造
</span><span class='line'>    switch (returnType[0]){
</span><span class='line'>     ...
</span><span class='line'>    }
</span><span class='line'> 
</span><span class='line'>  if(!class_respondsToSelector(cls, JPSelector)){
</span><span class='line'>        class_addMethod(cls, JPSelector, JPImplementation, typeDescription);
</span><span class='line'>    } else {
</span><span class='line'>        class_replaceMethod(cls, JPSelector, JPImplementation,typeDescription);
</span><span class='line'>    }
</span><span class='line'>}
</span></code></pre></td></tr></table></div></figure>


<ul>
<li>3:然后改写每个替换方法类的forwadInvocation的实现进行拦截，如果拦截到的Invocation的selctor转化成JPSelector能够响应，说明是一个替换方法，则从Invocation中取参数后调用JPSelector的IMP；</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>static void JPForwardInvocation(id slf, SEL selector, NSInvocation *invocation)
</span><span class='line'>{
</span><span class='line'>    NSMethodSignature *methodSignature = [invocation methodSignature];
</span><span class='line'>    NSInteger numberOfArguments = [methodSignature numberOfArguments];
</span><span class='line'>    
</span><span class='line'>    NSString *selectorName = NSStringFromSelector(invocation.selector);
</span><span class='line'>    NSString *JPSelectorName = [NSString stringWithFormat:@"_JP@", selectorName];
</span><span class='line'>    SEL JPSelector = NSSelectorFromString(JPSelectorName);
</span><span class='line'>    
</span><span class='line'>    if (!class_respondsToSelector(object_getClass(slf), JPSelector)) {
</span><span class='line'>      ...
</span><span class='line'>    }
</span><span class='line'>    
</span><span class='line'>    NSMutableArray *argList = [[NSMutableArray alloc] init];
</span><span class='line'>    [argList addObject:slf];
</span><span class='line'>
</span><span class='line'>    for (NSUInteger i = 2; i &lt; numberOfArguments; i++) {
</span><span class='line'>      ...
</span><span class='line'>    }
</span><span class='line'>    
</span><span class='line'>    //获取参数之后invoke JPSector调用JSFunction的实现
</span><span class='line'>    @synchronized(_context) {
</span><span class='line'>        _TMPInvocationArguments = formatOCToJSList(argList);
</span><span class='line'>
</span><span class='line'>        [invocation setSelector:JPSelector];
</span><span class='line'>        [invocation invoke];
</span><span class='line'>        
</span><span class='line'>        _TMPInvocationArguments = nil;
</span><span class='line'>    }
</span><span class='line'>}
</span></code></pre></td></tr></table></div></figure>


<h2>Patch现场复原的补充</h2>

<p>Patch现场恢复的功能主要用于连续更新脚本的应用场景。由于IOS的App应用按Home键或者被电话中断的时候，应用实际上是首先进入到后台运行阶段（applicationWillResignActive），当我们下次再次使用App的时候，如果后台应用没有被终止（applicationWillTerminate），那么App不会走appliation:didFinishLaunchingWithOptions方法，而是会走（applicationWillEnterForeground）。 对于这种场景如果我们连续更新线上脚本，那么第二次脚本更新则无法保留最开始的方法实现，另外恢复现场功能也有助于我们撤销线上脚本能够恢复应用的本身代码功能。</p>

<h4>（1）WaxPatch的现场恢复</h4>

<p>在Wax中通过wax_start(&ldquo;init lua file&rdquo;)启动框架并通过脚本替换类方法，通过wax_end()停止使用waxPatch环境。 Wax的官方维护版本中也没有现场恢复功能，替换方法的现场保存也是我们维护团队自行加入的，其实就是在替换方法或者新增方法的时候对原始现场（替换类／新增类＋替换方法/新增方法）进行cache，当需要恢复patch现场的时候通过cache进行复原。 下面简单说一下wax中的现场保存和恢复功能：</p>

<p>首先是在方法替换的时候，记录替换类＋替换方法</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>static BOOL overrideMethod(lua_State *L, wax_instance_userdata *instanceUserdata){
</span><span class='line'>  ...
</span><span class='line'>  
</span><span class='line'>  if(instImp) {
</span><span class='line'>        if(!class_respondsToSelector(klass, newSelector)) {
</span><span class='line'>            class_addMethod(klass, newSelector, prevImp, typeDescription);
</span><span class='line'>        } else {
</span><span class='line'>            class_replaceMethod(klass, newSelector, prevImp, typeDescription);
</span><span class='line'>        }
</span><span class='line'>        success = YES;
</span><span class='line'>        
</span><span class='line'>        NSDictionary *dict = @{@"class" : klass,
</span><span class='line'>                               @"sel" : selector ? NSStringFromSelector(selector) : [NSNull null],
</span><span class='line'>                               @"sel_objc" : newSelector ? NSStringFromSelector(newSelector) : [NSNull null], // objcXXXX
</span><span class='line'>                               @"typeDesc" : typeDescription ? [NSString stringWithUTF8String:typeDescription] : [NSNull null],
</span><span class='line'>                               @"identifier" : identifier
</span><span class='line'>                               };
</span><span class='line'>        addMethodReplaceDict(dict);
</span><span class='line'>    } 
</span><span class='line'>  
</span><span class='line'>  ...
</span><span class='line'>}
</span><span class='line'>  </span></code></pre></td></tr></table></div></figure>


<p>当Wax_end调用的时候恢复现场：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>//调用wax_end
</span><span class='line'>void wax_end() {
</span><span class='line'>    wax_clear();
</span><span class='line'>    [wax_gc stop];
</span><span class='line'>    lua_close(wax_currentLuaState());
</span><span class='line'>    currentL = 0;
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>//wax_clear()恢复现场
</span><span class='line'>
</span><span class='line'>/// 重置所有被wax修改的方法和类
</span><span class='line'>void wax_clear() {
</span><span class='line'>    // methods rollback
</span><span class='line'>    for (NSDictionary *dict in replacedMethodArray) {
</span><span class='line'>        Class class = dict[@"class"];
</span><span class='line'>        NSString *sel_str = dict[@"sel"];
</span><span class='line'>        NSString *sel_objc_str = dict[@"sel_objc"];
</span><span class='line'>        NSString *typeDesc = dict[@"typeDesc"];
</span><span class='line'>        NSString *identifier = dict[@"identifier"];
</span><span class='line'>        if (identifier) {
</span><span class='line'>            [[LDAOPAspect instance] removeAnInterceptorWithIdentifier:identifier];
</span><span class='line'>        }
</span><span class='line'>        
</span><span class='line'>        if (sel_str && ![sel_str isKindOfClass:[NSNull class]]
</span><span class='line'>            && sel_objc_str && ![sel_objc_str isKindOfClass:[NSNull class]]
</span><span class='line'>            && typeDesc && ![typeDesc isKindOfClass:[NSNull class]]) {
</span><span class='line'>            SEL sel = NSSelectorFromString(sel_str);
</span><span class='line'>            SEL sel_objc = NSSelectorFromString(sel_objc_str); // objcXXXX
</span><span class='line'>            IMP imp = class_getMethodImplementation(class, sel_objc);
</span><span class='line'>            class_replaceMethod(class, sel, imp, typeDesc.UTF8String);
</span><span class='line'>        }
</span><span class='line'>    }
</span><span class='line'>    
</span><span class='line'>    [replacedMethodArray removeAllObjects];
</span><span class='line'>    [replacedMethodArray release];
</span><span class='line'>    replacedMethodArray = nil;
</span><span class='line'>    
</span><span class='line'>    // class rollback
</span><span class='line'>    for (NSDictionary *dict in modifiedClassArray) {
</span><span class='line'>        NSString *className = dict[@"class"];
</span><span class='line'>        NSInteger version = [dict[@"version"] intValue];
</span><span class='line'>        Class class = NSClassFromString(className);
</span><span class='line'>        class_setVersion(class, version);
</span><span class='line'>    }
</span><span class='line'>    [modifiedClassArray removeAllObjects];
</span><span class='line'>    [modifiedClassArray release];
</span><span class='line'>    modifiedClassArray = nil;
</span><span class='line'>}
</span></code></pre></td></tr></table></div></figure>


<h4>（2）JSPatch的现场恢复</h4>

<p>为了跟Wax配合使用，本文在JSPatch添加了一样的调用方式和现场恢复功能；源码地址参考：</p>

<ul>
<li>增加现场恢复的JSPatchDemo:<a href="https://github.com/philonpang/JSPatch.git">https://github.com/philonpang/JSPatch.git</a></li>
</ul>


<p>说明如下：</p>

<p>（1）在JPEngine.h 中添加了两个启动和结束的调用函数如下：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>void js_start(NSString* initScript);
</span><span class='line'>void js_end();</span></code></pre></td></tr></table></div></figure>


<p>(2) JPEngine.m 中调用函数的实现以及恢复现场对部分代码的修改：主要是利用了替换方法和新增方法的cache（_JSOverideMethods, 主要是这个）</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>//处理替换方法,selector指回最初的IMP，JPSelector和ORIGSelector都指向未实现IMP
</span><span class='line'> if([JPSelectorName hasPrefix:@"_JP"]){
</span><span class='line'>     if (class_getMethodImplementation(cls, @selector(forwardInvocation:)) == (IMP)JPForwardInvocation) {
</span><span class='line'>         SEL ORIGforwardSelector = @selector(ORIGforwardInvocation:);
</span><span class='line'>         IMP ORIGforwardImp = class_getMethodImplementation(cls, ORIGforwardSelector);
</span><span class='line'>         class_replaceMethod(cls, @selector(forwardInvocation:), ORIGforwardImp, "v@:@");
</span><span class='line'>         class_replaceMethod(cls, ORIGforwardSelector, _objc_msgForward, "v@:@");
</span><span class='line'>     }
</span><span class='line'>     
</span><span class='line'>     
</span><span class='line'>     NSString *selectorName = [JPSelectorName stringByReplacingOccurrencesOfString:@"_JP" withString:@""];
</span><span class='line'>     NSString *ORIGSelectorName = [JPSelectorName stringByReplacingOccurrencesOfString:@"_JP" withString:@"ORIG"];
</span><span class='line'>     
</span><span class='line'>     SEL JPSelector = NSSelectorFromString(JPSelectorName);
</span><span class='line'>     SEL selector = NSSelectorFromString(selectorName);
</span><span class='line'>     SEL ORIGSelector = NSSelectorFromString(ORIGSelectorName);
</span><span class='line'>     
</span><span class='line'>     if(class_respondsToSelector(cls, ORIGSelector) &&
</span><span class='line'>        class_respondsToSelector(cls, selector) &&
</span><span class='line'>        class_respondsToSelector(cls, JPSelector)){
</span><span class='line'>         NSMethodSignature *methodSignature = [cls instanceMethodSignatureForSelector:ORIGSelector];
</span><span class='line'>         Method method = class_getInstanceMethod(cls, ORIGSelector);
</span><span class='line'>         char *typeDescription = (char *)method_getTypeEncoding(method);
</span><span class='line'>         IMP forwardEmptyIMP = getEmptyMsgForwardIMP(typeDescription, methodSignature);
</span><span class='line'>         IMP ORIGSelectorImp = class_getMethodImplementation(cls, ORIGSelector);
</span><span class='line'>         
</span><span class='line'>         class_replaceMethod(cls, selector, ORIGSelectorImp, typeDescription);
</span><span class='line'>         class_replaceMethod(cls, JPSelector, forwardEmptyIMP, typeDescription);
</span><span class='line'>         class_replaceMethod(cls, ORIGSelector, forwardEmptyIMP, typeDescription);
</span><span class='line'>     }
</span><span class='line'> }
</span><span class='line'> 
</span><span class='line'> //处理添加的新方法
</span><span class='line'> else {
</span><span class='line'>     isClsNew = YES;
</span><span class='line'>     SEL JPSelector = NSSelectorFromString(JPSelectorName);
</span><span class='line'>     if(class_respondsToSelector(cls, JPSelector)){
</span><span class='line'>         NSMethodSignature *methodSignature = [cls instanceMethodSignatureForSelector:JPSelector];
</span><span class='line'>         Method method = class_getInstanceMethod(cls, JPSelector);
</span><span class='line'>         char *typeDescription = (char *)method_getTypeEncoding(method);
</span><span class='line'>         IMP forwardEmptyIMP = getEmptyMsgForwardIMP(typeDescription, methodSignature);
</span><span class='line'>         
</span><span class='line'>         class_replaceMethod(cls, JPSelector, forwardEmptyIMP, typeDescription);
</span><span class='line'>     }
</span><span class='line'> }</span></code></pre></td></tr></table></div></figure>


<h2>HotfixPatch的那些坑</h2>

<p>WaxPatch之前被一些同事抱怨有不少坑，JSPatch在使用过程中也会遇到不少坑，所以虽然这两个框架现在虽然都能够做到新增可执行代码，但是将其应用到开发功能组件还不太可取。</p>

<p>比如说我在第一次使用JSPatch遇到了一个坑：（后面想单写一个博客收集一下我们团队使用Patch遇到的坑～～）</p>

<ul>
<li><p>在JS脚本改写派生类中未实现的继承类的 optional protocol方法时，tableView reload的时候不会调用JS的补丁方法，但是在tableView中显式调用可以调用替换的selector方法；另外如果在派生类中重写这个protocol方法，则可以调起；</p></li>
<li><p>&hellip;</p></li>
</ul>


<p>先写这么多了，本来想写一下我们的patch管理方案，觉得没有什么可说了，就不写了～</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[基于ReactiveCocoa的MVVM探索]]></title>
    <link href="http://ios.devphilon.com/blog/2015/06/04/reactivecocoa-mvvm/"/>
    <updated>2015-06-04T15:49:37+08:00</updated>
    <id>http://ios.devphilon.com/blog/2015/06/04/reactivecocoa-mvvm</id>
    <content type="html"><![CDATA[<h2>前言</h2>

<p>一直觉得对于具体功能模块的设计模式来说，没有什么值得研究和讨论的。觉得iOS提供的MVC模式已经能够很好的利用到产品的开发中去，对于大多数开发人员来说，最熟悉最得心应手的设计模式莫过于此。</p>

<p>但是随着业务需求的膨涨、页面交互的体验优化、业务模式的逐渐丰富，我们一直习以为常的MVC模式中，某些Controller的UI交互代码＋业务逻辑代码已经达到上千行的规模。当我们维护app、或进行新功能的扩充、或提供其他模块的调用接口时，复杂混乱的controller逻辑让我们头疼不已。</p>

<p>于是我们开始将Controlller的业务逻辑代码进行拆分，拆分部分逐渐形成了viewModel层，于是在现下移动客户端领域开始兴起了MVVM模式(V-VM-M)。随着FaceBook的“<a href="https://github.com/facebook/react-native">React Native</a>“跨平台开发框架，以及之前就出现的<a href="https://github.com/ReactiveCocoa/ReactiveCocoa">ReactiveCocoa</a>响应式编程模式的推出，MVVM设计模式在IOS移动端正逐渐被得心应手的开始使用。</p>

<p>本文在在学习了解React Native和ReactiveCocoa的基础上，对在IOS开发框架中如何采用MVVM模式进行了一定的探索和实践，并在实际的工程项目中如何利用MVC和MVVM做混合模式开发给出一定的建议，部分内容可能偏理论一点，不妥之处，望指教更正。</p>

<p>关于ReactiveCocoa和MVVM的学习资料：<a href="https://www.google.com/stars/mzm33xlrlwxgw/profile/folio/ssf_68299747347db8bc?hl=zh-CN">点击这里-Chrome书签</a></p>

<p>通过学习资料了解完ReactiveCocoa的基本概念之后，我们可以从下面一张图对ReactiveCocoa有一个整体理解：
<img src="http://ios.devphilon.com/images/FRP_ReactiveCocoa_large.png"></p>

<p>核心概念是RACSignal，相当于一个信号管道，接收信号源的信号，将信号依次发送给订阅者，在RACSignal基础上我们在MVVM模式下用得比较多的是RACCommand，信号到来开始执行，每次执行产生一个回调Signal。 具体的理解可以参考学习资料，讲的很清楚。</p>

<p>目前最新版本的ReactiveCocoa开始支持Swift，要求最低发布版本为IOS8，所以我们可以使用支持IOS6的最高版本， 当接入ReactiveCocoa之后，在性能上会慢1～2倍，但不影响app的直接体验，另外在调试部分也需要程序员看懂信号的来源和出处，打断点进行调试。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>platform :ios, '6.0'
</span><span class='line'>inhibit_all_warnings!
</span><span class='line'>
</span><span class='line'>workspace 'WTestReactiveCocoa'
</span><span class='line'>xcodeproj 'TestReactiveCocoa'
</span><span class='line'>
</span><span class='line'>target :TestReactiveCocoa do
</span><span class='line'>    pod 'ReactiveCocoa', '~&gt; 2.5'
</span><span class='line'>
</span><span class='line'>    #设置pod target需要link的工程target
</span><span class='line'>    link_with 'TestReactiveCocoa'
</span><span class='line'>end
</span><span class='line'>
</span></code></pre></td></tr></table></div></figure>


<p>本文主要介绍通过ReactiveCocoa进行MVVM模式的开发实践，具体的应用模式如下：</p>

<p><img src="http://ios.devphilon.com/images/MVVMReactiveCocoa.png"></p>

<h2>一、关于view层和viewModel层的Binding</h2>

<p>对于某个业务功能（这里指某个controller），从代码集来看，肯定是一堆系统原生view组件和自定义view组件在controller.view中的聚集。所有的叶子view组件节点都是以controller.view为根节点，作为其subview存在于controller中。所以view层其实可以看作是以controller.view为根节点的树状结构，负责view的创建、布局、和viewModel的binding、以及页面的交互效果（包括动画、跳转、切换等），只涉及到页面交互处理，不涉及业务逻辑的处理。</p>

<p>而对于viewModel来说，一般和controller是一一对应的，view层可以强依赖viewModel层，而viewModel层一定不能引用view层的任何对象。 view层中涉及业务逻辑处理的任何交互均需要通过signal信号告知viewModel层或者直接调用viewModel的command命令执行，同时view层也可以监听viewModel中定义的signal或者command执行发出的signal完成页面交互逻辑的处理。</p>

<h3>具体处理过程</h3>

<p>在controller初始化时，为该controller初始化一个对应的viewModel对象。这个viewModel可以只是个壳，viewModel中的具体属性对象可以通过前一个controller赋值初始化，也可以在当前controller中发出某个signal之后通过Model层提供的service进行初始化。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>- (instancetype)init
</span><span class='line'>{
</span><span class='line'>    if (self = [super init]) {
</span><span class='line'>        _fhcViewModel = [CPArenaFootHallContainerViewModel new];
</span><span class='line'>        [self setupContent];
</span><span class='line'>    }
</span><span class='line'>    return self;
</span><span class='line'>}
</span></code></pre></td></tr></table></div></figure>


<p>完成初始化之后，需要在viewDidLoad方法中在view组件创建之后，完成view层和viewModel层的binding。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>- (void)viewDidLoad
</span><span class='line'>{
</span><span class='line'>    [super viewDidLoad];
</span><span class='line'>    [self setupContent];
</span><span class='line'>    [self bindViewModel];
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>/**
</span><span class='line'> * 将controller中的view和ViewModel进行binding
</span><span class='line'> */
</span><span class='line'>-(void) bindViewModel{
</span><span class='line'>    //监控初始化hallModel command的执行
</span><span class='line'>    @weakify(self);
</span><span class='line'>    [[self.fhcViewModel.loadHallModel execute:@(YES)] subscribeNext:^(id statusCode){
</span><span class='line'>      //to do something
</span><span class='line'>    }];
</span><span class='line'> }
</span></code></pre></td></tr></table></div></figure>




<blockquote><p>tip: </p><p>(1) 并不是所有的view组件都需要和viewModel绑定，通常如果view组件的显示属性是常量定义（如显示标题、某个业务组件的icon图片名称), 这些属性没有必要放入viewModel层，也就没有必要进行binding。</p><p>(2) 对于controller中跟viewModel中的对象息息相关的各个view对象（获取textField的输入值作为viewModel中某个operation的输入，点击某个按钮执行viewModel的某个command）, 则需要在controller中进行绑定。</p></blockquote>


<p>不同的情景其binding的方法也不一样：</p>

<ul>
<li>情景1:</li>
</ul>


<p>如果subview是UIkit自带的view组件（如label，button, textfield, textview, imageView, alert, action sheet等等），则可以直接通过ReactiveCocoa直接进行view和viewModel之间的绑定。</p>

<p>ReactiveCocoa提供绑定category的的基本View组件包括：MKAnnotationView、UIActionSheet、UIAlertView、UIBarButtonItem、UIButton、UICollectionReusableView、UIControl、UIDatePicker、UIGestureRecognizer、UIImagePickerController、UIRefreshControl、UISegmentedControl、UISlider、UIStepper、UISwitch、UITableViewCell、UITableViewHeaderFooterView、UITextField、UITextView。</p>

<p>而我们平常经常用到的可能会有UITextField，UITextView、UIControl、UIButton、UIActionSheet、UIAlertView这几个，具体的使用方法在ReativeCoccoa的<a href="http://www.itiger.me/?p=38">示例</a>中可以查看。其封装核心是监控view组件的delegate方法或者selector方法执行，每当执行时发送一个执行信号；view层将该信号和viewModel层进行绑定，自己也可以监控这些信号完成某些交互行为。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>- (void)bindViewModel {
</span><span class='line'>    self.title = self.viewModel.title;
</span><span class='line'>    RAC(self.viewModel, searchText) = self.searchTextField.rac_textSignal;
</span><span class='line'>    self.searchButton.rac_command = self.viewModel.executeSearch;
</span><span class='line'>    RAC([UIApplication sharedApplication], networkActivityIndicatorVisible) = self.viewModel.executeSearch.executing;
</span><span class='line'>    RAC(self.loadingIndicator, hidden) = [self.viewModel.executeSearch.executing not];
</span><span class='line'>    
</span><span class='line'>    [self.viewModel.executeSearch.executionSignals
</span><span class='line'>     subscribeNext:^(id x) {
</span><span class='line'>         [self.searchTextField resignFirstResponder];
</span><span class='line'>     }];
</span><span class='line'>}
</span><span class='line'>
</span></code></pre></td></tr></table></div></figure>


<ul>
<li>情景2:</li>
</ul>


<p>情景2主要是针对subview是通过单独文件封装的view组件，如UITableView的自定义tableviewCell，某些在基础view组件上进行封装的view组件等。如果是新写这些view组件，可以考虑通过ReactiveCocoa的方式完成；如果是已经成型的组件，则需要根据具体情况看是否改造成响应式模式；</p>

<p>（1）如果组件中只绑定一两个viewModel中非集合类型的属性值，则直接通过开放view组件的属性值，在controller中完成binding； 具体的binding方法和情景1类似。</p>

<p>（2）如果组件中有较多的基础view组件，且都和viewModel相关，则考虑为该view组件定义一个view对象，并作为view组件的属性。controller将view组件的viewModel属性和controller对应的viewModel相应属性绑定，当controller中对应的viewModel发生变化，将会把变化传递给view 组件，在view组件中根据viewModel的属性变化去改变具体的基础view组件显示值；</p>

<p><strong><em>这个跟Reative Native的props属性传递的思想类似：对于一些component，通过属性传入，在componnet中可以通过这些props去对基础UI组件赋值，当传入属性值改变之后，对应component的相应UI组件的显示值也会发生变化。</em></strong></p>

<p>在引入ReactiveCocoa之前，view组件和viewModel的对应如下所示：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>- (void)setContent:(CPArenaMatchViewModel *)content
</span><span class='line'>{
</span><span class='line'>    if ([content.sps count] != 3 || [content.supportRates count] != 3) {
</span><span class='line'>        return;
</span><span class='line'>    }
</span><span class='line'>    
</span><span class='line'>    [self.winButton setHeaderText:content.teamAName];
</span><span class='line'>    [self.winButton setDetailText:[NSString stringWithFormat:@"胜 %@",content.sps[0]]];
</span><span class='line'>    [self.drawButton setHeaderText:@"平"];
</span><span class='line'>}
</span></code></pre></td></tr></table></div></figure>


<p>在引入ReactiveCocoa之后，具体viewModel和view组件的binding过程则根情景1种的binding类似。</p>

<ul>
<li>情景3:</li>
</ul>


<p>对于比较复杂的系统view，如tableView、colletionView、pageView等，目前ReactiveCocoa中没有提供category进行绑定。</p>

<p>个人觉得对tableview整体进行封装没有必要，一方面对于app来说，大多数复杂的界面都是在tableview的基础上定制完成的，定制越多，封装就越没有意义；另外这些复杂的系统view组件一般提供了很好的扩展性和自刷新机制（ReloadData），如tableview的section、header view、footer view、tableviewcell等，这些扩展性就对应了情景2种提到的第二种情况。</p>

<p>对于这种情景的处理方法：我们可以通过传入一个viewModel对象给自定义的view或者cell，当页面刷新的时候，可以根据监控到的传入viewModel变化刷新界面；即使是非定制的view，则可以对view的属性直接通过controller对应的viewModel直接赋值；</p>

<p>截取了tableView:cellForRowAtIndexPath的绑定代码：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>
</span><span class='line'>    if ([moduleKey isEqualToString:kArenaHallDaily]) {
</span><span class='line'>        
</span><span class='line'>        static NSString *dailyIdentifier = @"dailyCell";
</span><span class='line'>        CPArenaHallDailyCell *cell = [tableView dequeueReusableCellWithIdentifier:dailyIdentifier];
</span><span class='line'>        if (cell == nil) {
</span><span class='line'>          ...
</span><span class='line'>        }
</span><span class='line'>        
</span><span class='line'>        //直接读取viewModel中的值进行view组件的赋值，当tableview reload的时候，重新读取一次
</span><span class='line'>        [cell setContent:[self.fhViewModel.hallModel arenaHallDailyContent]];
</span><span class='line'>        return cell;
</span><span class='line'>        
</span><span class='line'>    } 
</span></code></pre></td></tr></table></div></figure>


<ul>
<li>情景4:</li>
</ul>


<p>而某些container-controller（tabController和NavigationController除外），在两个或者多个controller之间切换，controller.view中基本没有交互，交互主要在navigationBar上。NavigationBar的交互主要是controller跳转和切换，可能需要从Model中获取一些数据进行判定。</p>

<p>对于这种情景，我觉得没有必要通过MVVM模式进行处理，直接按照MVC模式处理即可，Model的获取通过Model层提供的APIService获取（单例），其跳转或者切换的controller中可以直接通过APIService获取之前已经初始化的Model对象；</p>

<h3>tip</h3>

<blockquote><p>(1) 关于view的常量定义仍然属于View层，没有必要将其放进viewModel中（viewModel还只是保存view需要跟Model打交道，对其进行加工的部分）；</p><p>(2) 在view层，对于无交互且无数据刷新需求的view组件不进行绑定； 对于有交互的view组件，如果交互不会对viewModel进行改变，也无需绑定；对于一些需要等待viewModel初始化完成才能进行数据显示的view组件，则可以考虑统一监控viewModel，当viewModel有更新的时候统一刷新各个view组件；</p><p>(3) 一个controller拥有一个viewModel， 比较复杂的view组件也可以拥有一个viewModel，但其viewModel的初始化在controller的viewModel中完成；</p></blockquote>


<h2>关于controller的简化和跳转</h2>

<p>引入ReactiveCocoa有两个目的：</p>

<p>第一个:是在controller中一些交互比较频繁、状态逻辑较复杂的情况，可以通过ReactiveCocoa的Signal机制监听view组件的状态变化简化状态逻辑的判定。 比如说ReactiveCocoa的官方经典案例：用户名密码登录框；</p>

<p>第二个目的就是本文主要阐述的方向，通过引入ReactiveCocoa简化controller， 将controller中的交互逻辑和业务逻辑分开，形成有效的MVVM开发模式。在将MVVM模式应用的具体的业务组件工程中可能会引出下面一些问题：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>1. controller之间的跳转到底应该放在view层还是viewModel层？
</span><span class='line'>2. 什么代码可以从controller中分离，如何分离？
</span></code></pre></td></tr></table></div></figure>


<h3>Controller间的跳转</h3>

<p>在传统MVC模式下的controller跳转，需要在当前controller中import另外一个controller头文件，然后传入参数初始化controller，再调用navigation-push 或者 viewController-present， 相当于controller跳转是放到了view层。传统的MVC模式给我们带来的痛苦是无法对controller层进行单元测试，并且controlle中业务逻辑和交互逻辑混乱不堪，所以我们才希望通过MVVC模式来简化controller中的代码；</p>

<p>当我们将业务逻辑拆分到viewModel中，那么controller的跳转是继续留在view层还是将其拆分到viewModel层呢？我们来看一下分别放在两个层的优缺点：</p>

<ol>
<li><p>如果继续放在view层：MVVM模式号称的去UI的测试也就无法去验证跳转逻辑，无法做完整性测试；并且每个controller的viewModel是孤立的，只能对其做单元测试；</p></li>
<li><p>如果直接拆分放到viewModel层，它就背离了我们之前的分层标准，viewModel层绝对不能依赖view层的任何对象；如果我们通过viewModel层提供的service去做跳转，在MVC模式和MVVM模式混合开发的工程中，则稍显复杂</p></li>
</ol>


<p>所以本文觉得还是把controller的跳转继续放在view层；相当于通过view层的navigator去完成跳转，其实这跟React Native的跳转也是不谋而合的（在react Native中，每一个controller都被当作是navigator下的一个scene，每个scene跳转的时候都会保留对全局navigator的引用，直接在view层的代码中调用navigator.push完成）。另外controller的跳转对于整个app来说，也是属于view交互的定性。</p>

<h3>交互逻辑和业务逻辑如何分离？</h3>

<p>前文提到MVVM模式的主要工作就是将controller中的业务逻辑拆分出来，那在一个controller中如何定义业务逻辑，具体哪些代码需要拆分到viewModel中呢？前文也提到view层的主要工作是完成view的创建、布局、动画，以及交互和跳转处理。</p>

<p>view组件创建过程中，一些属性值需要在创建时通过参数传入，如果这些属性值是通过常量（如标题、按钮文字、alert提示文字、按钮的图片名称等），则不需要放到viewModel中；如果属性值是需要从Model中获取的数据（有些时候需要加工处理）进行初始化，则需要将其通过viewModel提供，一开始可以先传入一个空的viewModel，并建立view属性和viewModel的binding，当viewModel初始化完成或者更新的时候，通过signal更新view组件。另外在创建、布局view的时候可能需要一些model属性的判定，这些判断逻辑直接通过引用viewModel的数值即可。view层除开viewModel的绑定之外，只能读取viewModel中的值去初始化界面。</p>

<p>而交互逻辑和业务逻辑的主要交叉点出现在controller的生命周期和view组件的action操作中：</p>

<ol>
<li><p>比如说contorller的生命周期，当controller初始化并push之后，会先跳转到viewDidload中初始化subview，然后在viewWillAppear中完成布局，并向viewModel或者model层请求数据。 或者在在生命周期中需要监听某些事件通知、执行某些定时器等，这些逻辑代码就应该放到viewModel中。</p></li>
<li><p>另外对于view组件的action操作，当touch事件发生之后，既要完成view的显示或者隐藏、或重新布局、或者更新数据，又需要向viewModel层发起某些操作，这些向viewModel发起的操作逻辑也必须放到viewModel中；</p></li>
</ol>


<blockquote><p>当我们把这些业务逻辑拆分出去之后，<strong><em>如何在某些交互或者某个生命周期状态发生时自动调用对应的业务逻辑呢？业务逻辑在viewModel中又是如何组织的呢？</em></strong></p></blockquote>

<p>业务逻辑在viewModel中通过RACCommand进行管理，当调起某个command的执行之后，首先完成业务处理，并通过signal（return value）通知调用者发起回调。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>//执行添加leaveTimer
</span><span class='line'>@weakify(self);
</span><span class='line'>self.addLeaveTimerCommand = [[RACCommand alloc] initWithSignalBlock:^RACSignal *(id input) {
</span><span class='line'>    @strongify(self);
</span><span class='line'>    [self addLeaveTimer];
</span><span class='line'>    return [RACSignal return:@(YES)];
</span><span class='line'>}];
</span></code></pre></td></tr></table></div></figure>


<p>如果业务处理是异步的，则需要在viewModel中定义全局Signal（RACSubject），当异步业务处理执行完成或者错误的时候，通过RACSubject通知调用者。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>//初始化更新Signal，供view层监听
</span><span class='line'>self.refreshResultSignal = [[RACSubject subject] setNameWithFormat:@"CPArenaFottHallVM-refreshResultSignal"];
</span><span class='line'>    
</span><span class='line'>    
</span><span class='line'>/**
</span><span class='line'> * 重新刷新hallModel（hallModel其实应该是一个比较通用的ViewModel）
</span><span class='line'> */
</span><span class='line'>-(void)refreshContent
</span><span class='line'>{
</span><span class='line'>    void (^ completion)(void) = ^{
</span><span class='line'>        [self.refreshResultSignal sendCompleted];
</span><span class='line'>    };
</span><span class='line'>    
</span><span class='line'>    //通过service重新load HallModel数据
</span><span class='line'>    if(1){
</span><span class='line'>        [self.refreshResultSignal sendNext:@"hello"];
</span><span class='line'>        completion();
</span><span class='line'>    }
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>    </span></code></pre></td></tr></table></div></figure>


<p>生命周期状态的监听我们通过rac_signalforSelector去完成，某些view组件的action，则直接通过view组件的category，或者监听view组件的delegate回调来完成监听。也可以对这些信号进行组合、过滤、map、返回参数的封装，这些都是ReactiveCocoa提供的方法；</p>

<p>监听controller生命周期状态如下：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>//当view层disappear时，通知viewModel层开始计时
</span><span class='line'>[[self rac_signalForSelector:@selector(viewWillDisappear:)] subscribeNext:^(id x) {
</span><span class='line'>    @strongify(self);
</span><span class='line'>    [self.fhViewModel.addLeaveTimerCommand execute:nil];
</span><span class='line'>}];
</span><span class='line'>
</span><span class='line'>
</span><span class='line'>//监控view层的显示Signal
</span><span class='line'>[[self rac_signalForSelector:@selector(viewWillAppear:)] subscribeNext:^(id x) {
</span><span class='line'>    @strongify(self);
</span><span class='line'>    [self.fhViewModel.refreshCheckCommand execute:nil];
</span><span class='line'>}];
</span><span class='line'>
</span></code></pre></td></tr></table></div></figure>


<p>监听view组件的delegate回调如下：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>//监听当前HeadView的Accessory的click动作
</span><span class='line'>RACSignal *clickAccessorySignal = [self rac_signalForSelector:@selector(didClickAccessoryViewInHeaderView:) fromProtocol:@protocol(CPArenaHeaderViewDelegate)];
</span><span class='line'>[[clickAccessorySignal map:^id(RACTuple *tuple) {
</span><span class='line'>    return tuple.first;
</span><span class='line'>}] subscribeNext:^(CPArenaHeaderView *headerView) {
</span><span class='line'>  //to do something
</span><span class='line'>}
</span><span class='line'>
</span></code></pre></td></tr></table></div></figure>


<h3>tip:</h3>

<blockquote><ol>
<li>将某些delegate方法通过signal监听之后，其实是可以删去这些delegate方法，但是编译器报警告，所以保留原有的delegate方法，只是方法实现为空；真正的方法实现放到Signal监听之中；</li>
</ol>
</blockquote>

<h2>viewModel层和Model层之间的交互</h2>

<p>在Model层,ReactiveCocoa提供如下基础对象signal改造的支持：NSArray、NSData、NSDictionary、NSEnumerator、NSFileHandle、NSIndexSet、NSInvocation
NSNotificationCenter、NSObject、NSOrderedSet、NSSet、NSString、NSURLConnection、NSUserDefaults. 如果工程中的Model层也是通过响应式编程实现，这些category可能对Model层通知viewModel层有很大的作用，目前还没有对model层响应式编程仔细研究（这不是必要的），这里说一下Model层在MVVM模式的主要工作模式。</p>

<h3>APIService的发起路径和过程</h3>

<p>在MVC模式下，我们通常直接在controller中创建Model层提供的APIService去获取数据。而在MVVM模式中，相应APIService的请求会转移到ViewModel层，而ViewModel的初始化是根据Model层的访问完成的，其具体访问路径如下：</p>

<p>（1）当点击某个按钮或者发起初始化signal，点击动作或者创建会向viewModel发出一个signal执行RACCommand（RACCommand，执行 一次产生一个signal， 这个command在viewModel层定义和创建），当前view层会定监听RACCommand的执行，并根据返回的event实时更新view；</p>

<p>（2）viewModel接受这个signal：</p>

<ul>
<li><p>如果signal是创建ViewModel，则判断当前viewModel是否初始化，如果没有，则向Model层发起一个 initial operation；</p></li>
<li><p>如果signal改变了viewModel中的值，viewModel的变化会自动通知binding的view组件更新；此外如果viewModel的改变和Model层有关联，则向Model层发起一个update operation；</p></li>
<li><p>当前viewModel向Model发起operation之后，当前viewModel需要定制监控发起的这个signal，并将后台返回的signal信号进行处理，或更新viewModel，或向view层监控的signal发送各个operation的完成事件；</p></li>
</ul>


<p>（3）Model层不仅仅是实体对象的定义，还包括APIService的实现，APIService通过向后台发送request请求，当请求返回的时候能够根据实体定义初始化实体对象，并在Model层持有（或进一步持久化，保存为coredata或者db中）；</p>

<ul>
<li><p>当Model层接受到viewModel（MVVC）或者controller（MVC）的 initial operation时，查看Model层持有的对象，如果存在直接返回，如果不存在，则通过APIService向后台或者本地持久化发出请求，并将请求状态和结果push给ViewModel层或者controller层；</p></li>
<li><p>当Model层接收到update operation时，一般是先通过APIService发送update operation，根据operation的结果操作本地持久化对象（或者重新拉取一遍，或者直接在update operation中返回数据对原有持久对象进行更换）；</p></li>
</ul>


<h3>关于Model和网络请求的生命周期</h3>

<p>关于Model层什么时机进行初始化，Model层持有对象的生命周期，以及网络请求的生命周期？</p>

<ul>
<li>Model层的初始化，分为不同的场景，初始化的时机也不一样：</li>
</ul>


<p>(1) 如果Model是全局需要的，如UserModel，则可以在appdelegate中直接初始化；</p>

<p>(2) 如果是MVC模式，则直接在controller中直接调用APIService初始化；</p>

<p>(3) 如果是MVVM模式，则通过调用viewModel中进行初始化；</p>

<ul>
<li>生命周期：</li>
</ul>


<p>(1) 如果是全局Model，则通过单例Service进行保持；</p>

<p>(2) 如果是跟controller保持一致的，则通过普通service进行初始化；</p>

<ul>
<li>网络请求的生命周期：</li>
</ul>


<p>(1) 如果是单例的service，网络请求的生命周期肯定小于单例，service持久化的Model对象也会一直存在；</p>

<p>(2) 如果是非单例service，service持久化的Model对象随着service的dealloc而销毁， 网络请求的生命周期也会被service cancel掉；仍然小于service；</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[通用JSBridge的设计和实现]]></title>
    <link href="http://ios.devphilon.com/blog/2015/05/29/jsbridge/"/>
    <updated>2015-05-29T21:30:27+08:00</updated>
    <id>http://ios.devphilon.com/blog/2015/05/29/jsbridge</id>
    <content type="html"><![CDATA[<h3>前言</h3>

<p>对于商务类的app，随着app注册使用人数递增，app的运营者们就会逐渐考虑在应用中开展一些推广活动。大多数活动具备时效性强、运营时间短的特征，一般产品们和运营者们都是通过wap页面快速投放到产品的活动模块。Wap页面可以声文并茂地介绍活动，但活动的最终目标是通过获取特权、跳转进入本地功能模块，最后达成交易。如何建立wap页面和本地Native页面的深度交互，这就需要用到本文介绍的JSBridge。</p>

<p>此外一些平台类的产品，如大家每天都在使用的微信、支付宝、手机qq等，无一例外都在使用集成JSBridge的webContainer完成众多业务组件功能，大大减少了客户端Native开发的工作量，不仅节约了大量人力开发成本，还能避开产品上线更新的版本审核周期限制（特别是IOS平台）。当然这些超级APP有强大的技术力量支撑，通过JSBridge有计划的进行API规范接口，不断向前端Wap开发人员开放，并在版本上向下兼容。但对于我们刚起步运营的中小级app来说暂时还没有必要如此大张旗鼓，相反前面提到的wap活动推广则是我们的主要需求。</p>

<p>为了满足这个需求，本文通过提炼JSBridge的核心部分改造成JSService方式供各个不同的产品零修改方式使用。各个不同的产品只需要按照插件的方式提供Native扩展接口，并在各自封装的webContainer中调用JSService对Wap调用进行拦截处理。</p>

<h3>具体产品应用</h3>

<p>目前该框架同时覆盖了Android和IOS平台，在我司的几个电商类产品中都得到了很好的使用，并趋于稳定。
本文的Demo工程运行效果如下：</p>

<p><img src="http://ios.devphilon.com/images/jsapidemo_ios.png">
<img src="http://ios.devphilon.com/images/jsapidemo_android.jpg"></p>

<h3>关于JSAPI的接口封装</h3>

<p>JSAPI的封装包括核心JS和对外开放接口JS两个部分。 核心JS部分通过拦截某Q的wap请求页面获取，获取的JS进行编码混淆处理，已经通过调试进行了注释，其主要过程就是对参数和回调进行封装，并构建一个url链接通过创建一个隐藏的iframe进行发送。<a href="">核心JS代码阅读</a></p>

<p>对参数和回调进行封装部分的代码如下：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>//invoke
</span><span class='line'>  //mapp.invoke("device", "getDeviceInfo", e);
</span><span class='line'>  //@param e 类 必须
</span><span class='line'>  //@param n 类方法 必须
</span><span class='line'>  //@param i 同步回调的js方法
</span><span class='line'>  //@param s 
</span><span class='line'>    function k(e, n, i, s) {
</span><span class='line'>        if (!e || !n) return null;
</span><span class='line'>        var o, u;
</span><span class='line'>        i = r.call(arguments, 2), //相当于调用Array.prototype.slice(arguments) == arguments.slice(2),获取argument数组2以后的元素
</span><span class='line'>        
</span><span class='line'>      //令s等于回调函数
</span><span class='line'>      s = i.length && i[i.length - 1],
</span><span class='line'>        s && typeof s == "function" ? i.pop() : typeof s == "undefined" ? i.pop() : s = null,
</span><span class='line'>        
</span><span class='line'>      //u为当前存储回调函数的index；
</span><span class='line'>      u = b(s);
</span><span class='line'>        
</span><span class='line'>      //如果当前版本支持Bridge
</span><span class='line'>      if (C(e, n)) {
</span><span class='line'>          //将传进来的所有参数生成一个url字符串；
</span><span class='line'>            o = "ldjsbridge:" + "/" + "/" + encodeURIComponent(e) + "/" + encodeURIComponent(n),
</span><span class='line'>            i.forEach(function(e, t) {
</span><span class='line'>                typeof e == "object" && (e = JSON.stringify(e)),
</span><span class='line'>                t === 0 ? o += "?p=": o += "&p" + t + "=",
</span><span class='line'>                o += encodeURIComponent(String(e))
</span><span class='line'>            }),
</span><span class='line'>            (o += "#" + u); //带上存储回调的数组index;
</span><span class='line'>          
</span><span class='line'>           
</span><span class='line'>          //执行生成的url, 有些函数是同步执行完毕，直接调用回调函数；而有些函数的调用要通过异步调用执行，需要通过
</span><span class='line'>          //全局调用去完成；
</span><span class='line'>              var f = N(o);
</span><span class='line'>            if (t.iOS) {
</span><span class='line'>                f = f ? f.result: null;
</span><span class='line'>                if (!s) return f; //如果无回调函数，直接返回结果；
</span><span class='line'>            }
</span><span class='line'>        }else {
</span><span class='line'>          console.log("mappapi: the version don't support mapp." + e + "." + n);
</span><span class='line'>      }
</span><span class='line'>    }
</span></code></pre></td></tr></table></div></figure>


<p>创建iframe发送JSBridge调用请求：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>//创建一个iframe，执行src，供拦截
</span><span class='line'>function N(n, r) {
</span><span class='line'>  console.log("logOpenURL:&gt;&gt;" + n);
</span><span class='line'>    var i = document.createElement("iframe");
</span><span class='line'>    i.style.cssText = "display:none;width:0px;height:0px;";
</span><span class='line'>    var s = function() {
</span><span class='line'>      //通过全局执行函数执行回调函数；监听iframe是否加载完毕
</span><span class='line'>        E(r, {
</span><span class='line'>            r: -201,
</span><span class='line'>            result: "error"
</span><span class='line'>        })
</span><span class='line'>    };
</span><span class='line'>    
</span><span class='line'>  //ios平台，令iframe的src为url，onload函数为全局回调函数
</span><span class='line'>  //并将iframe插入到body或者html的子节点中；
</span><span class='line'>  t.iOS && (i.onload = s, i.src = n);
</span><span class='line'>    var o = document.body || document.documentElement; 
</span><span class='line'>    o.appendChild(i),
</span><span class='line'>    t.android && (i.onload = s, i.src = n);
</span><span class='line'>  
</span><span class='line'>  //
</span><span class='line'>    var u = t.__RETURN_VALUE;
</span><span class='line'>  //当iframe执行完成之后，最后执行settimeout 0语句
</span><span class='line'>    return t.__RETURN_VALUE = e,
</span><span class='line'>    setTimeout(function() {
</span><span class='line'>        i.parentNode.removeChild(i)
</span><span class='line'>    },
</span><span class='line'>    0),
</span><span class='line'>    u
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>对外开放接口的封装：（使用者只需要对该部分进行接口扩展即可）</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>mapp.build("mapp.device.getDeviceInfo", {
</span><span class='line'>    iOS: function(e) {
</span><span class='line'>      return mapp.invoke("device", "getDeviceInfo", e);
</span><span class='line'>    },
</span><span class='line'>    android: function(e) {
</span><span class='line'>      var t = e;
</span><span class='line'>      e = function(e) {
</span><span class='line'>          try {
</span><span class='line'>              e = JSON.parse(e)
</span><span class='line'>          } catch(n) {}
</span><span class='line'>          t && t(e)
</span><span class='line'>      },
</span><span class='line'>      mapp.invoke("device", "getDeviceInfo", e)
</span><span class='line'>    },
</span><span class='line'>    support: {
</span><span class='line'>        iOS: "1.0",
</span><span class='line'>        android: "1.0"
</span><span class='line'>    }
</span><span class='line'>}),
</span><span class='line'>
</span></code></pre></td></tr></table></div></figure>


<h4>核心JS代码调用说明</h4>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>
</span><span class='line'>mapp.version: mappAPI自身版本号
</span><span class='line'>
</span><span class='line'>mapp.iOS: 如果在ios app中，值为true
</span><span class='line'>
</span><span class='line'>mapp.android: 如果在android app中，值为true
</span><span class='line'>
</span><span class='line'>mapp.support: 检查当前app环境是否支持该接口，支持返回true
</span><span class='line'>
</span><span class='line'>  mapp.support("mqq.device.getClientInfo")
</span><span class='line'>
</span><span class='line'>mapp.callback: 用于生成回调名字，跟着invoke参数传给客户端，供客户端回调
</span><span class='line'>
</span><span class='line'>  var callbackName = mapp.callback(function(type, index){     console.log("type: " + type + ", index: " + index);    });
</span><span class='line'>
</span><span class='line'>mapp.invoke 方法:
</span><span class='line'>
</span><span class='line'>mapp核心方法，用于调用客户端接口。
</span><span class='line'>
</span><span class='line'>      @param {String} namespace 命名空间
</span><span class='line'>      @param {String} method 接口名字
</span><span class='line'>      @param {Object/String} params 可选，API调用的参数
</span><span class='line'>      @param {Function} callback 可选，API调用的回调
</span><span class='line'>
</span><span class='line'>* 调用普通的无参数接口：
</span><span class='line'>
</span><span class='line'>      mapp.invoke("ns", "method");
</span><span class='line'>      
</span><span class='line'>* 调用有异步回调函数的接口：
</span><span class='line'>
</span><span class='line'>      mapp.invoke("ns", "method", function(data){
</span><span class='line'>          console.log(data);
</span><span class='line'>      });
</span><span class='line'>      
</span><span class='line'>      或
</span><span class='line'>      
</span><span class='line'>      mapp.invoke("ns", "method", {
</span><span class='line'>          "params" : params   //参数通过json封装
</span><span class='line'>          "callback" : mapp.callback(handler), //生成回调名字
</span><span class='line'>      });
</span><span class='line'>
</span><span class='line'>
</span><span class='line'>* 如果有多个参数调用：
</span><span class='line'>
</span><span class='line'>      mapp.invoke("ns", "method", param1, param2 /*,...*/,callback);
</span><span class='line'>      
</span><span class='line'>      </span></code></pre></td></tr></table></div></figure>


<h3>JSService的具体实现－插件运行机制</h3>

<p>JSService部分是基于Phonegap的Cordova引擎的基础上简化而来，其基本原理参照Cordova的引擎原理如图所示：</p>

<p><img src="http://ios.devphilon.com/images/JSBridgeIOS_1.png"></p>

<p>一般app中都有自己定制的Webcontainer，为了更好的跟已有项目相融合，在Cordova的基础上我们进行了简化，通过JSAPIService服务的方式进行插件扩展开发如图所示：</p>

<p><img src="http://ios.devphilon.com/images/JSBridgeIOS_2.png"></p>

<p>本JSBridge是基于Phonegap的Cordova引擎的基础上简化而来, Android平台Webview和JS的交互方式共有三种:</p>

<ol>
<li>ExposedJsApi：js直接调用java对象的方法；（同步）</li>
<li>重载chromeClient的prompt 截获方案；(异步)</li>
<li>url截获+webview.loadUrl回调的方案；（异步）</li>
</ol>


<p>为了和IOS保持一致的JSAPI，只能选用第三套方案；</p>

<p><a href="">具体实现参考源码</a></p>

<h3>基于JSService的插件开发、配置和使用</h3>

<h4>IOS平台</h4>

<p>在Native部分，定义一个模块插件对应于创建一个插件类, 模块中的每个插件接口对应插件类中某个方法。
集成LDJSBridge_IOS框架之后，只需要继承框架中的插件基类LDJSPlugin，如下所示：</p>

<ul>
<li>插件接口定义</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>#import "LDJSPlugin.h"
</span><span class='line'>@interface LDPDevice : LDJSPlugin
</span><span class='line'>{}
</span><span class='line'>
</span><span class='line'>//@func 获取设备信息
</span><span class='line'>- (void)getDeviceInfo:(LDJSInvokedUrlCommand*)command;
</span><span class='line'>
</span><span class='line'>@end
</span></code></pre></td></tr></table></div></figure>


<p></p>

<ul>
<li>自定义插件接口实现</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>@implementation LDPDevice
</span><span class='line'>
</span><span class='line'>/**
</span><span class='line'> *@func 获取设备信息
</span><span class='line'> */
</span><span class='line'>- (void)getDeviceInfo:(LDJSInvokedUrlCommand*)command{
</span><span class='line'>    //读取设备信息
</span><span class='line'>    NSMutableDictionary* deviceProperties = [NSMutableDictionary dictionaryWithCapacity:4];
</span><span class='line'>    
</span><span class='line'>    UIDevice* device = [UIDevice currentDevice];
</span><span class='line'>    [deviceProperties setObject:[device systemName] forKey:@"systemName"];
</span><span class='line'>    [deviceProperties setObject:[device systemVersion] forKey:@"systemVersion"];
</span><span class='line'>    [deviceProperties setObject:[device model] forKey:@"model"];
</span><span class='line'>    [deviceProperties setObject:[device modelVersion] forKey:@"modelVersion"];
</span><span class='line'>    [deviceProperties setObject:[self uniqueAppInstanceIdentifier] forKey:@"identifier"];
</span><span class='line'>    
</span><span class='line'>    LDJSPluginResult* pluginResult = [LDJSPluginResult resultWithStatus:LDJSCommandStatus_OK messageAsDictionary:[NSDictionary dictionaryWithDictionary:deviceProperties]];
</span><span class='line'>    
</span><span class='line'>    [self.commandDelegate sendPluginResult:pluginResult callbackId:command.callbackId];
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>@end</span></code></pre></td></tr></table></div></figure>


<ul>
<li>在plugin.json文件中对plugin插件的统一配置</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>{
</span><span class='line'>    "update": "",
</span><span class='line'>    "module": "mapp",
</span><span class='line'>    "plugins": [
</span><span class='line'>        {
</span><span class='line'>            "pluginname": "device",
</span><span class='line'>            "pluginclass": "LDPDevice",
</span><span class='line'>            "exports": [
</span><span class='line'>                {
</span><span class='line'>                    "showmethod": "getDeviceInfo",
</span><span class='line'>                    "realmethod": "getDeviceInfo"
</span><span class='line'>                }
</span><span class='line'>            ]
</span><span class='line'>        }
</span><span class='line'>  ]
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<ul>
<li>在webContainer中对JSService初始化, 当初始化完成之后，向前端页面发送一个ReadyEvent，前端即可开始调用JSAPI接口；</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>//注册插件Service
</span><span class='line'>    if(_bridgeService == nil){
</span><span class='line'>        _bridgeService = [[LDJSService alloc] initBridgeServiceWithConfig:@"PluginConfig.json"];
</span><span class='line'>    }
</span><span class='line'>    [_bridgeService connect:_webview Controller:self];
</span><span class='line'>
</span><span class='line'>
</span><span class='line'>/**
</span><span class='line'> Called when the webview finishes loading.  This stops the activity view.
</span><span class='line'> */
</span><span class='line'>- (void)webViewDidFinishLoad:(UIWebView*)theWebView{
</span><span class='line'>    NSLog(@"Finished load of: %@", theWebView.request.URL);
</span><span class='line'>    //当webview finish load之后，发event事件通知前端JSBridgeService已经就绪
</span><span class='line'>    //监听事件由各个产品自行决定
</span><span class='line'>    [_bridgeService readyWithEvent:@"LDJSBridgeServiceReady"];
</span><span class='line'>}
</span></code></pre></td></tr></table></div></figure>


<h4>Android平台</h4>

<ul>
<li>插件接口定义</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>public class LDPDevice extends LDJSPlugin {
</span><span class='line'>          public static final String TAG = "Device";
</span><span class='line'>
</span><span class='line'>  /**
</span><span class='line'>           * Constructor.
</span><span class='line'>           */
</span><span class='line'>          public LDPDevice() {
</span><span class='line'>          }
</span><span class='line'>      }
</span><span class='line'>      </span></code></pre></td></tr></table></div></figure>


<ul>
<li>LDJSPlugin 属性方法说明</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>/**
</span><span class='line'>* Plugins must extend this class and override one of the execute methods.
</span><span class='line'>*/
</span><span class='line'>public class LDJSPlugin {
</span><span class='line'>          public String id;
</span><span class='line'>          
</span><span class='line'>          //在插件初始化的时候，会初始化当前插件所属的webview和controller
</span><span class='line'>  //供插件方法接口 返回处理结果
</span><span class='line'>    public WebView webView; 
</span><span class='line'>  public LDJSActivityInterface activityInterface;
</span><span class='line'>  
</span><span class='line'>  //所有自定义插件需要重载此方法
</span><span class='line'>  public boolean execute(String action, LDJSParams args, LDJSCallbackContext callbackContext) throws JSONException {
</span><span class='line'>          return false;
</span><span class='line'>          }
</span><span class='line'>          
</span><span class='line'>      }   
</span><span class='line'>      </span></code></pre></td></tr></table></div></figure>


<ul>
<li>自定义插件接口实现</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>@Override
</span><span class='line'>  public boolean execute(String action, LDJSParams args, LDJSCallbackContext callbackContext) throws JSONException {
</span><span class='line'>      if (action.equals("getDeviceInfo")) {
</span><span class='line'>          JSONObject r = new JSONObject();
</span><span class='line'>          r.put("uuid", LDPDevice.uuid);
</span><span class='line'>          r.put("version", this.getOSVersion());
</span><span class='line'>          r.put("platform", this.getPlatform());
</span><span class='line'>          r.put("model", this.getModel());
</span><span class='line'>          callbackContext.success(r);
</span><span class='line'>      }
</span><span class='line'>      else {
</span><span class='line'>          return false;
</span><span class='line'>      }
</span><span class='line'>      return true;
</span><span class='line'>  }
</span></code></pre></td></tr></table></div></figure>


<ul>
<li>在封装的webContainer中注册服务并调用：</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
<span class='line-number'>49</span>
<span class='line-number'>50</span>
<span class='line-number'>51</span>
<span class='line-number'>52</span>
<span class='line-number'>53</span>
<span class='line-number'>54</span>
<span class='line-number'>55</span>
<span class='line-number'>56</span>
<span class='line-number'>57</span>
<span class='line-number'>58</span>
<span class='line-number'>59</span>
<span class='line-number'>60</span>
<span class='line-number'>61</span>
<span class='line-number'>62</span>
<span class='line-number'>63</span>
<span class='line-number'>64</span>
<span class='line-number'>65</span>
<span class='line-number'>66</span>
<span class='line-number'>67</span>
<span class='line-number'>68</span>
<span class='line-number'>69</span>
<span class='line-number'>70</span>
<span class='line-number'>71</span>
<span class='line-number'>72</span>
<span class='line-number'>73</span>
<span class='line-number'>74</span>
<span class='line-number'>75</span>
<span class='line-number'>76</span>
<span class='line-number'>77</span>
<span class='line-number'>78</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>  /**
</span><span class='line'>     * 初始化Activity,打开网页，注册插件服务
</span><span class='line'>     */
</span><span class='line'>    public void initActivity() {
</span><span class='line'>        //创建webview和显示view
</span><span class='line'>      createGapView();
</span><span class='line'>      createViews();
</span><span class='line'>
</span><span class='line'>      //注册插件服务
</span><span class='line'>      if(jsBridgeService == null){
</span><span class='line'>          jsBridgeService = new LDJSService(_webview, this, "PluginConfig.json");
</span><span class='line'>      }
</span><span class='line'>
</span><span class='line'>      //加载请求
</span><span class='line'>      if(this.url != null && !this.url.equalsIgnoreCase("")){
</span><span class='line'>          _webview.loadUrl(this.url);
</span><span class='line'>      }
</span><span class='line'>    }
</span><span class='line'>    
</span><span class='line'>    
</span><span class='line'>    
</span><span class='line'> /**
</span><span class='line'>     * 初始化webview，如果需要调用JSAPI，必须为Webview注册WebViewClient和WebChromeClient
</span><span class='line'>     */
</span><span class='line'>    @SuppressLint("SetJavaScriptEnabled")
</span><span class='line'>    public void createGapView(){
</span><span class='line'>      if(_webview == null){
</span><span class='line'>          _webview = new WebView(LDPBaseWebViewActivity.this, null);
</span><span class='line'>          //设置允许webview和javascript交互
</span><span class='line'>            _webview.getSettings().setJavaScriptEnabled(true);
</span><span class='line'>            _webview.getSettings().setCacheMode(WebSettings.LOAD_NO_CACHE);
</span><span class='line'>
</span><span class='line'>          //绑定webviewclient
</span><span class='line'>          _webviewClient = new WebViewClient(){
</span><span class='line'>              public void onPageStarted(WebView view, String url, Bitmap favicon){
</span><span class='line'>                  super.onPageStarted(view, url, favicon);
</span><span class='line'>                  isWebviewStarted = true;
</span><span class='line'>              }
</span><span class='line'>
</span><span class='line'>              public void onPageFinished(WebView view, String url) {
</span><span class='line'>                  super.onPageFinished(view, url);
</span><span class='line'>                      //发送事件通知前端
</span><span class='line'>                  if(isWebviewStarted){
</span><span class='line'>                      //在page加载之后，加载核心JS，前端页面可以在document.ready函数中直接调用了；
</span><span class='line'>                      jsBridgeService.onWebPageFinished();
</span><span class='line'>                          jsBridgeService.readyWithEventName("LDJSBridgeServiceReady");
</span><span class='line'>                  }
</span><span class='line'>                  isWebviewStarted = false;
</span><span class='line'>              }
</span><span class='line'>
</span><span class='line'>                @Override
</span><span class='line'>                public boolean shouldOverrideUrlLoading(WebView view, String url) {
</span><span class='line'>                      if(url.startsWith("about:")){
</span><span class='line'>                          return true;
</span><span class='line'>                      }
</span><span class='line'>                      if(url.startsWith(LDJSService.LDJSBridgeScheme)){
</span><span class='line'>                          //处理JSBridge特定的Scheme
</span><span class='line'>                          jsBridgeService.handleURLFromWebview(url);
</span><span class='line'>                          return true;
</span><span class='line'>                      }
</span><span class='line'>
</span><span class='line'>                      return false;
</span><span class='line'>                }
</span><span class='line'>          };
</span><span class='line'>
</span><span class='line'>          _webview.setWebViewClient(_webviewClient);
</span><span class='line'>          //绑定chromeClient
</span><span class='line'>          _webviewChromeClient = new WebChromeClient(){
</span><span class='line'>              @Override
</span><span class='line'>              public boolean onJsAlert(WebView view, String url, String message,
</span><span class='line'>                      JsResult result) {
</span><span class='line'>                  return super.onJsAlert(view, url, message, result);
</span><span class='line'>              }
</span><span class='line'>          };
</span><span class='line'>          _webview.setWebChromeClient(_webviewChromeClient);
</span><span class='line'>      }
</span><span class='line'>    }
</span><span class='line'>
</span></code></pre></td></tr></table></div></figure>


<h3>结束</h3>

<p>第一次写博客，写得糙和不好的地方望见谅，本人将会不断改善和提高自身能力；目前源码部分还没有得到许可上传到Github部分（待得到许可，应该问题不大，一定第一时间上传），所以本博客主要提供大概的解决方案，望能够和有需要的人士交流沟通具体实现方式的差异。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[如何搭建自己的github博客，我从这里启航]]></title>
    <link href="http://ios.devphilon.com/blog/2015/05/22/helloworld/"/>
    <updated>2015-05-22T10:25:23+08:00</updated>
    <id>http://ios.devphilon.com/blog/2015/05/22/helloworld</id>
    <content type="html"><![CDATA[<p>来某易公司差不多三个季度了，比起刚入职时候的期待、兴奋、专注，现在是期待和兴奋已被磨灭殆尽，在技术方面也越来越不专注了。越是闲下来，越不想时光在这样的停摆期悄悄溜走，特别想让自己仍然在IOS和前端领域深耕细作。 折腾了两天，终于把自己的独立博客在github搭建起来了，以后希望能够在此和大家分享当前前端前沿技术的学习和实践，也希望能够在IOS的深入学习上能够一点一滴的由浅入深，</p>
]]></content>
  </entry>
  
</feed>
